<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>OOP: ArrayList vs. LinkedList trong Java: Cuộc chiến hiệu năng và khi nào nên chọn ai? | Blog của Hữu Khang</title>
<meta name="keywords" content="">
<meta name="description" content="Cả ArrayList và LinkedList đều dùng để lưu danh sách, nhưng cấu trúc bên trong hoàn toàn khác biệt. Bài viết này sẽ mổ xẻ hiệu năng và giúp bạn chọn đúng công cụ cho từng bài toán.">
<meta name="author" content="Hữu Khang">
<link rel="canonical" href="https://thanhprowin1.github.io/posts/so-sanh-arraylist-va-linkedlist/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.a482bf00fa5c046040ef7973ad5fdf5657890cacb596c93f1382f664ca542074.css" integrity="" rel="preload stylesheet" as="style">
<link rel="icon" href="https://thanhprowin1.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://thanhprowin1.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://thanhprowin1.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://thanhprowin1.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://thanhprowin1.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://thanhprowin1.github.io/posts/so-sanh-arraylist-va-linkedlist/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:url" content="https://thanhprowin1.github.io/posts/so-sanh-arraylist-va-linkedlist/">
  <meta property="og:site_name" content="Blog của Hữu Khang">
  <meta property="og:title" content="OOP: ArrayList vs. LinkedList trong Java: Cuộc chiến hiệu năng và khi nào nên chọn ai?">
  <meta property="og:description" content="Cả ArrayList và LinkedList đều dùng để lưu danh sách, nhưng cấu trúc bên trong hoàn toàn khác biệt. Bài viết này sẽ mổ xẻ hiệu năng và giúp bạn chọn đúng công cụ cho từng bài toán.">
  <meta property="og:locale" content="vi">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-10-12T22:50:00+07:00">
    <meta property="article:modified_time" content="2025-10-12T22:50:00+07:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OOP: ArrayList vs. LinkedList trong Java: Cuộc chiến hiệu năng và khi nào nên chọn ai?">
<meta name="twitter:description" content="Cả ArrayList và LinkedList đều dùng để lưu danh sách, nhưng cấu trúc bên trong hoàn toàn khác biệt. Bài viết này sẽ mổ xẻ hiệu năng và giúp bạn chọn đúng công cụ cho từng bài toán.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://thanhprowin1.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "OOP: ArrayList vs. LinkedList trong Java: Cuộc chiến hiệu năng và khi nào nên chọn ai?",
      "item": "https://thanhprowin1.github.io/posts/so-sanh-arraylist-va-linkedlist/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "OOP: ArrayList vs. LinkedList trong Java: Cuộc chiến hiệu năng và khi nào nên chọn ai?",
  "name": "OOP: ArrayList vs. LinkedList trong Java: Cuộc chiến hiệu năng và khi nào nên chọn ai?",
  "description": "Cả ArrayList và LinkedList đều dùng để lưu danh sách, nhưng cấu trúc bên trong hoàn toàn khác biệt. Bài viết này sẽ mổ xẻ hiệu năng và giúp bạn chọn đúng công cụ cho từng bài toán.",
  "keywords": [
    
  ],
  "articleBody": "Giới thiệu Trong thế giới Java, khi cần lưu trữ một danh sách các đối tượng, ArrayList và LinkedList là hai cái tên đầu tiên xuất hiện. Cả hai đều là một phần của Java Collections Framework và cùng triển khai List Interface. Tuy nhiên, đằng sau vẻ ngoài tương đồng đó là hai cơ chế hoạt động hoàn toàn khác biệt, dẫn đến sự chênh lệch “một trời một vực” về hiệu năng trong các tình huống khác nhau.\nTrong bài viết này, chúng ta sẽ mổ xẻ cấu trúc bên trong của cả hai, so sánh hiệu năng, và rút ra kết luận cuối cùng: Khi nào nên dùng ArrayList và khi nào nên dùng LinkedList? 🧐\n1. ArrayList - Người bạn thân của Mảng (Array) Hãy tưởng tượng ArrayList như một dãy ghế trong rạp chiếu phim, mỗi ghế được đánh số thứ tự rõ ràng.\nCấu trúc bên trong: ArrayList được xây dựng dựa trên một mảng (array) động. Điều này có nghĩa là các phần tử được lưu trữ trong các ô nhớ liền kề nhau. Điểm mạnh: Vì các phần tử nằm liền kề, việc truy cập một phần tử bất kỳ theo chỉ số (index) là cực kỳ nhanh. Giống như bạn có thể đi thẳng đến ghế số 50 mà không cần đi qua 49 ghế đầu tiên. Thao tác này có độ phức tạp là $O(1)$. Điểm yếu: Khi bạn thêm hoặc xóa một phần tử ở giữa danh sách, tất cả các phần tử đứng sau nó sẽ phải dịch chuyển để lấp đầy hoặc tạo ra khoảng trống. Đây là một thao tác rất tốn kém, có độ phức tạp $O(n)$. Ví dụ Code ArrayList: import java.util.ArrayList; import java.util.List; public class ArrayListExample { public static void main(String[] args) { List\u003cString\u003e fruits = new ArrayList\u003c\u003e(); // Thêm phần tử fruits.add(\"Táo\"); fruits.add(\"Cam\"); fruits.add(\"Xoài\"); // Truy cập phần tử - Rất nhanh! System.out.println(\"Phần tử ở vị trí 1: \" + fruits.get(1)); // Output: Cam // Xóa phần tử ở giữa - Chậm vì \"Xoài\" phải dịch chuyển lên fruits.remove(1); System.out.println(\"Danh sách sau khi xóa: \" + fruits); // Output: [Táo, Xoài] } } 2. LinkedList - Chuỗi Mắt Xích Linh Hoạt Hãy tưởng tượng LinkedList như một đoàn tàu, mỗi toa tàu (node) biết toa nào đứng trước và toa nào đứng sau nó.\nCấu trúc bên trong: LinkedList được cấu tạo từ các node. Mỗi node chứa dữ liệu của phần tử và hai “mối nối”: một tham chiếu đến node đứng trước và một tham chiếu đến node đứng sau. Điểm mạnh: Việc thêm hoặc xóa một phần tử là cực kỳ nhanh, vì chúng ta chỉ cần thay đổi vài “mối nối” mà không cần di chuyển các node khác. Thao tác này có độ phức tạp là $O(1)$. Điểm yếu: Để truy cập một phần tử ở vị trí thứ n, LinkedList phải duyệt qua tất cả n-1 phần tử đầu tiên, giống như bạn phải đi qua tất cả các toa tàu để đến được toa cuối cùng. Thao tác này rất chậm, có độ phức tạp $O(n)$. Ví dụ Code LinkedList: import java.util.LinkedList; import java.util.List; public class LinkedListExample { public static void main(String[] args) { LinkedList\u003cString\u003e animals = new LinkedList\u003c\u003e(); // Thêm phần tử animals.add(\"Chó\"); animals.add(\"Mèo\"); animals.add(\"Chuột\"); // Thêm vào đầu danh sách - Rất nhanh! animals.addFirst(\"Voi\"); // Truy cập phần tử - Chậm vì phải duyệt từ đầu System.out.println(\"Phần tử ở vị trí 2: \" + animals.get(2)); // Output: Mèo System.out.println(\"Danh sách động vật: \" + animals); // Output: [Voi, Chó, Mèo, Chuột] } } 3. Đặt lên bàn cân: So sánh trực tiếp Để dễ hình dung, chúng ta hãy tóm tắt lại các điểm mạnh và yếu của từng loại dựa trên các thao tác thường gặp:\nVề phía ArrayList: ** Điểm mạnh nhất: Truy cập phần tử (get)**\nArrayList truy cập phần tử theo chỉ số (index) cực kỳ nhanh ($O(1)$). Vì dữ liệu được lưu trong một mảng liền kề, nó có thể nhảy thẳng đến vị trí mong muốn mà không cần duyệt qua các phần tử khác. ** Điểm yếu nhất: Thêm/xóa ở đầu hoặc giữa**\nĐây là thao tác rất chậm ($O(n)$) với ArrayList. Khi bạn thêm/xóa một phần tử, tất cả các phần tử phía sau nó đều phải dịch chuyển, gây tốn kém hiệu năng đáng kể. Về phía LinkedList: ** Điểm mạnh nhất: Thêm/xóa ở đầu hoặc giữa**\nLinkedList thực hiện thao tác này cực kỳ nhanh ($O(1)$). Nó chỉ cần thay đổi một vài “mối nối” (tham chiếu) giữa các phần tử liền kề mà không cần di chuyển bất cứ dữ liệu nào khác. ** Điểm yếu nhất: Truy cập phần tử (get)**\nĐể lấy một phần tử ở vị trí n, LinkedList phải bắt đầu từ đầu (hoặc cuối) và duyệt qua n phần tử. Đây là thao tác rất chậm ($O(n)$) khi danh sách lớn. Về bộ nhớ: ArrayList tốn ít bộ nhớ hơn vì chỉ lưu trữ dữ liệu. LinkedList tốn nhiều bộ nhớ hơn vì mỗi phần tử phải lưu thêm thông tin về mối nối đến phần tử trước và sau nó. ",
  "wordCount" : "864",
  "inLanguage": "en",
  "datePublished": "2025-10-12T22:50:00+07:00",
  "dateModified": "2025-10-12T22:50:00+07:00",
  "author":{
    "@type": "Person",
    "name": "Hữu Khang"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://thanhprowin1.github.io/posts/so-sanh-arraylist-va-linkedlist/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Blog của Hữu Khang",
    "logo": {
      "@type": "ImageObject",
      "url": "https://thanhprowin1.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://thanhprowin1.github.io/" accesskey="h" title="Blog của Hữu Khang (Alt + H)">Blog của Hữu Khang</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://thanhprowin1.github.io/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://thanhprowin1.github.io/posts/" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="https://thanhprowin1.github.io/about/" title="Về tôi">
                    <span>Về tôi</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      OOP: ArrayList vs. LinkedList trong Java: Cuộc chiến hiệu năng và khi nào nên chọn ai?
    </h1>
    <div class="post-description">
      Cả ArrayList và LinkedList đều dùng để lưu danh sách, nhưng cấu trúc bên trong hoàn toàn khác biệt. Bài viết này sẽ mổ xẻ hiệu năng và giúp bạn chọn đúng công cụ cho từng bài toán.
    </div>
    <div class="post-meta"><span title='2025-10-12 22:50:00 +0700 +07'>October 12, 2025</span>&nbsp;·&nbsp;<span>Hữu Khang</span>

</div>
  </header> 
  <div class="post-content"><h2 id="giới-thiệu">Giới thiệu<a hidden class="anchor" aria-hidden="true" href="#giới-thiệu">#</a></h2>
<p>Trong thế giới Java, khi cần lưu trữ một danh sách các đối tượng, <code>ArrayList</code> và <code>LinkedList</code> là hai cái tên đầu tiên xuất hiện. Cả hai đều là một phần của <strong>Java Collections Framework</strong> và cùng triển khai <code>List Interface</code>. Tuy nhiên, đằng sau vẻ ngoài tương đồng đó là hai cơ chế hoạt động hoàn toàn khác biệt, dẫn đến sự chênh lệch &ldquo;một trời một vực&rdquo; về hiệu năng trong các tình huống khác nhau.</p>
<p>Trong bài viết này, chúng ta sẽ mổ xẻ cấu trúc bên trong của cả hai, so sánh hiệu năng, và rút ra kết luận cuối cùng: <strong>Khi nào nên dùng ArrayList và khi nào nên dùng LinkedList?</strong> 🧐</p>
<hr>
<h2 id="1-arraylist---người-bạn-thân-của-mảng-array">1. ArrayList - Người bạn thân của Mảng (Array)<a hidden class="anchor" aria-hidden="true" href="#1-arraylist---người-bạn-thân-của-mảng-array">#</a></h2>
<p>Hãy tưởng tượng <code>ArrayList</code> như một dãy ghế trong rạp chiếu phim, mỗi ghế được đánh số thứ tự rõ ràng.</p>
<ul>
<li><strong>Cấu trúc bên trong:</strong> <code>ArrayList</code> được xây dựng dựa trên một <strong>mảng (array) động</strong>. Điều này có nghĩa là các phần tử được lưu trữ trong các ô nhớ liền kề nhau.</li>
<li><strong>Điểm mạnh:</strong> Vì các phần tử nằm liền kề, việc truy cập một phần tử bất kỳ theo chỉ số (index) là <strong>cực kỳ nhanh</strong>. Giống như bạn có thể đi thẳng đến ghế số 50 mà không cần đi qua 49 ghế đầu tiên. Thao tác này có độ phức tạp là $O(1)$.</li>
<li><strong>Điểm yếu:</strong> Khi bạn thêm hoặc xóa một phần tử ở giữa danh sách, tất cả các phần tử đứng sau nó sẽ phải <strong>dịch chuyển</strong> để lấp đầy hoặc tạo ra khoảng trống. Đây là một thao tác rất tốn kém, có độ phức tạp $O(n)$.</li>
</ul>
<h3 id="ví-dụ-code-arraylist">Ví dụ Code ArrayList:<a hidden class="anchor" aria-hidden="true" href="#ví-dụ-code-arraylist">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.ArrayList;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.List;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ArrayListExample</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>        List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> fruits <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Thêm phần tử</span>
</span></span><span style="display:flex;"><span>        fruits.<span style="color:#a6e22e">add</span>(<span style="color:#e6db74">&#34;Táo&#34;</span>);
</span></span><span style="display:flex;"><span>        fruits.<span style="color:#a6e22e">add</span>(<span style="color:#e6db74">&#34;Cam&#34;</span>);
</span></span><span style="display:flex;"><span>        fruits.<span style="color:#a6e22e">add</span>(<span style="color:#e6db74">&#34;Xoài&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Truy cập phần tử - Rất nhanh!</span>
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Phần tử ở vị trí 1: &#34;</span> <span style="color:#f92672">+</span> fruits.<span style="color:#a6e22e">get</span>(1)); <span style="color:#75715e">// Output: Cam</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Xóa phần tử ở giữa - Chậm vì &#34;Xoài&#34; phải dịch chuyển lên</span>
</span></span><span style="display:flex;"><span>        fruits.<span style="color:#a6e22e">remove</span>(1); 
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Danh sách sau khi xóa: &#34;</span> <span style="color:#f92672">+</span> fruits); <span style="color:#75715e">// Output: [Táo, Xoài]</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h2 id="2-linkedlist---chuỗi-mắt-xích-linh-hoạt">2. LinkedList - Chuỗi Mắt Xích Linh Hoạt<a hidden class="anchor" aria-hidden="true" href="#2-linkedlist---chuỗi-mắt-xích-linh-hoạt">#</a></h2>
<p>Hãy tưởng tượng <code>LinkedList</code> như một đoàn tàu, mỗi toa tàu (node) biết toa nào đứng trước và toa nào đứng sau nó.</p>
<ul>
<li><strong>Cấu trúc bên trong:</strong> <code>LinkedList</code> được cấu tạo từ các <strong>node</strong>. Mỗi node chứa dữ liệu của phần tử và hai &ldquo;mối nối&rdquo;: một tham chiếu đến node đứng trước và một tham chiếu đến node đứng sau.</li>
<li><strong>Điểm mạnh:</strong> Việc thêm hoặc xóa một phần tử là <strong>cực kỳ nhanh</strong>, vì chúng ta chỉ cần thay đổi vài &ldquo;mối nối&rdquo; mà không cần di chuyển các node khác. Thao tác này có độ phức tạp là $O(1)$.</li>
<li><strong>Điểm yếu:</strong> Để truy cập một phần tử ở vị trí thứ <code>n</code>, <code>LinkedList</code> phải <strong>duyệt qua tất cả <code>n-1</code> phần tử đầu tiên</strong>, giống như bạn phải đi qua tất cả các toa tàu để đến được toa cuối cùng. Thao tác này rất chậm, có độ phức tạp $O(n)$.</li>
</ul>
<h3 id="ví-dụ-code-linkedlist">Ví dụ Code LinkedList:<a hidden class="anchor" aria-hidden="true" href="#ví-dụ-code-linkedlist">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.LinkedList;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.util.List;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LinkedListExample</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>        LinkedList<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> animals <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LinkedList<span style="color:#f92672">&lt;&gt;</span>();
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Thêm phần tử</span>
</span></span><span style="display:flex;"><span>        animals.<span style="color:#a6e22e">add</span>(<span style="color:#e6db74">&#34;Chó&#34;</span>);
</span></span><span style="display:flex;"><span>        animals.<span style="color:#a6e22e">add</span>(<span style="color:#e6db74">&#34;Mèo&#34;</span>);
</span></span><span style="display:flex;"><span>        animals.<span style="color:#a6e22e">add</span>(<span style="color:#e6db74">&#34;Chuột&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Thêm vào đầu danh sách - Rất nhanh!</span>
</span></span><span style="display:flex;"><span>        animals.<span style="color:#a6e22e">addFirst</span>(<span style="color:#e6db74">&#34;Voi&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Truy cập phần tử - Chậm vì phải duyệt từ đầu</span>
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Phần tử ở vị trí 2: &#34;</span> <span style="color:#f92672">+</span> animals.<span style="color:#a6e22e">get</span>(2)); <span style="color:#75715e">// Output: Mèo</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Danh sách động vật: &#34;</span> <span style="color:#f92672">+</span> animals); <span style="color:#75715e">// Output: [Voi, Chó, Mèo, Chuột]</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<hr>
<h2 id="3-đặt-lên-bàn-cân-so-sánh-trực-tiếp">3. Đặt lên bàn cân: So sánh trực tiếp<a hidden class="anchor" aria-hidden="true" href="#3-đặt-lên-bàn-cân-so-sánh-trực-tiếp">#</a></h2>
<p>Để dễ hình dung, chúng ta hãy tóm tắt lại các điểm mạnh và yếu của từng loại dựa trên các thao tác thường gặp:</p>
<h3 id="về-phía-arraylist">Về phía ArrayList:<a hidden class="anchor" aria-hidden="true" href="#về-phía-arraylist">#</a></h3>
<ul>
<li>
<p>** Điểm mạnh nhất: Truy cập phần tử (get)**</p>
<ul>
<li><code>ArrayList</code> truy cập phần tử theo chỉ số (index) <strong>cực kỳ nhanh</strong> ($O(1)$). Vì dữ liệu được lưu trong một mảng liền kề, nó có thể nhảy thẳng đến vị trí mong muốn mà không cần duyệt qua các phần tử khác.</li>
</ul>
</li>
<li>
<p>** Điểm yếu nhất: Thêm/xóa ở đầu hoặc giữa**</p>
<ul>
<li>Đây là thao tác <strong>rất chậm</strong> ($O(n)$) với <code>ArrayList</code>. Khi bạn thêm/xóa một phần tử, tất cả các phần tử phía sau nó đều phải dịch chuyển, gây tốn kém hiệu năng đáng kể.</li>
</ul>
</li>
</ul>
<h3 id="về-phía-linkedlist">Về phía LinkedList:<a hidden class="anchor" aria-hidden="true" href="#về-phía-linkedlist">#</a></h3>
<ul>
<li>
<p>** Điểm mạnh nhất: Thêm/xóa ở đầu hoặc giữa**</p>
<ul>
<li><code>LinkedList</code> thực hiện thao tác này <strong>cực kỳ nhanh</strong> ($O(1)$). Nó chỉ cần thay đổi một vài &ldquo;mối nối&rdquo; (tham chiếu) giữa các phần tử liền kề mà không cần di chuyển bất cứ dữ liệu nào khác.</li>
</ul>
</li>
<li>
<p>** Điểm yếu nhất: Truy cập phần tử (get)**</p>
<ul>
<li>Để lấy một phần tử ở vị trí <code>n</code>, <code>LinkedList</code> phải bắt đầu từ đầu (hoặc cuối) và duyệt qua <code>n</code> phần tử. Đây là thao tác <strong>rất chậm</strong> ($O(n)$) khi danh sách lớn.</li>
</ul>
</li>
</ul>
<h3 id="về-bộ-nhớ">Về bộ nhớ:<a hidden class="anchor" aria-hidden="true" href="#về-bộ-nhớ">#</a></h3>
<ul>
<li><code>ArrayList</code> tốn ít bộ nhớ hơn vì chỉ lưu trữ dữ liệu.</li>
<li><code>LinkedList</code> tốn nhiều bộ nhớ hơn vì mỗi phần tử phải lưu thêm thông tin về mối nối đến phần tử trước và sau nó.</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://thanhprowin1.github.io/">Blog của Hữu Khang</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
