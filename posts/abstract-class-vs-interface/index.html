<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>OOP: Abstract Class vs. Interface: Cuộc chiến của những &#39;Bản thiết kế&#39; trong Java | Blog của Hữu Khang</title>
<meta name="keywords" content="">
<meta name="description" content="Cả hai đều là những bản thiết kế cho các lớp khác, nhưng chúng phục vụ những mục đích rất khác nhau. Bài viết này sẽ làm rõ khi nào bạn nên dùng Lớp trừu tượng và khi nào nên dùng Giao diện.">
<meta name="author" content="Hữu Khang">
<link rel="canonical" href="https://thanhprowin1.github.io/posts/abstract-class-vs-interface/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.a482bf00fa5c046040ef7973ad5fdf5657890cacb596c93f1382f664ca542074.css" integrity="" rel="preload stylesheet" as="style">
<link rel="icon" href="https://thanhprowin1.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://thanhprowin1.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://thanhprowin1.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://thanhprowin1.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://thanhprowin1.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://thanhprowin1.github.io/posts/abstract-class-vs-interface/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:url" content="https://thanhprowin1.github.io/posts/abstract-class-vs-interface/">
  <meta property="og:site_name" content="Blog của Hữu Khang">
  <meta property="og:title" content="OOP: Abstract Class vs. Interface: Cuộc chiến của những &#39;Bản thiết kế&#39; trong Java">
  <meta property="og:description" content="Cả hai đều là những bản thiết kế cho các lớp khác, nhưng chúng phục vụ những mục đích rất khác nhau. Bài viết này sẽ làm rõ khi nào bạn nên dùng Lớp trừu tượng và khi nào nên dùng Giao diện.">
  <meta property="og:locale" content="vi">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-10-12T22:50:00+07:00">
    <meta property="article:modified_time" content="2025-10-12T22:50:00+07:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OOP: Abstract Class vs. Interface: Cuộc chiến của những &#39;Bản thiết kế&#39; trong Java">
<meta name="twitter:description" content="Cả hai đều là những bản thiết kế cho các lớp khác, nhưng chúng phục vụ những mục đích rất khác nhau. Bài viết này sẽ làm rõ khi nào bạn nên dùng Lớp trừu tượng và khi nào nên dùng Giao diện.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://thanhprowin1.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "OOP: Abstract Class vs. Interface: Cuộc chiến của những 'Bản thiết kế' trong Java",
      "item": "https://thanhprowin1.github.io/posts/abstract-class-vs-interface/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "OOP: Abstract Class vs. Interface: Cuộc chiến của những 'Bản thiết kế' trong Java",
  "name": "OOP: Abstract Class vs. Interface: Cuộc chiến của những \u0027Bản thiết kế\u0027 trong Java",
  "description": "Cả hai đều là những bản thiết kế cho các lớp khác, nhưng chúng phục vụ những mục đích rất khác nhau. Bài viết này sẽ làm rõ khi nào bạn nên dùng Lớp trừu tượng và khi nào nên dùng Giao diện.",
  "keywords": [
    
  ],
  "articleBody": "Giới thiệu Trong Lập trình Hướng đối tượng, cả Lớp trừu tượng (Abstract Class) và Giao diện (Interface) đều là những “bản thiết kế” mà chúng ta không thể tạo ra đối tượng trực tiếp. Thay vào đó, chúng được dùng để các lớp khác kế thừa hoặc triển khai, nhằm tạo ra một bộ quy tắc và cấu trúc chung.\nTuy nhiên, việc lựa chọn giữa chúng giống như chọn giữa một bộ khung nhà có sẵn vài bức tường (Abstract Class) và một bản vẽ thiết kế chi tiết trên giấy (Interface). Hãy cùng tìm hiểu sự khác biệt cốt lõi nhé.\n1. Lớp trừu tượng (Abstract Class) - “IS-A” Relationship Hãy nghĩ về một Abstract Class như một khuôn mẫu còn dang dở. Nó định nghĩa các đặc điểm và hành vi chung cho một nhóm các lớp có liên quan mật thiết với nhau.\nĐặc điểm: Có thể chứa cả phương thức trừu tượng (không có phần thân) và phương thức thông thường (có phần thân). Có thể có các biến thành viên (instance variables), hàm khởi tạo (constructor). Một lớp chỉ có thể kế thừa (extends) từ MỘT lớp trừu tượng duy nhất. Mục đích: Chia sẻ code chung giữa các lớp con có cùng bản chất. Nó trả lời cho câu hỏi “Đối tượng này LÀ MỘT cái gì đó”. Ví dụ Code: Một lớp Animal trừu tượng có thể có phương thức sleep() chung cho mọi con vật, nhưng phương thức makeSound() thì phải để cho từng lớp con (như Dog, Cat) tự định nghĩa.\n// Lớp trừu tượng - Khuôn mẫu còn dang dở abstract class Animal { private String name; // Constructor public Animal(String name) { this.name = name; } // Phương thức thông thường (có sẵn code) public void sleep() { System.out.println(name + \" đang ngủ... zzz\"); } // Phương thức trừu tượng (bắt buộc lớp con phải định nghĩa) public abstract void makeSound(); } // Lớp con kế thừa class Dog extends Animal { public Dog(String name) { super(name); } @Override public void makeSound() { System.out.println(\"Gâu gâu!\"); } } 2. Giao diện (Interface) - “CAN-DO” Relationship Hãy nghĩ về một Interface như một bản hợp đồng. Nó chỉ định nghĩa những hành vi mà một lớp phải có, nhưng không quan tâm lớp đó thực hiện chúng như thế nào.\nĐặc điểm: Theo truyền thống, nó chỉ chứa các phương thức trừu tượng và các hằng số (public static final). (Java 8+ cho phép thêm default và static methods). Không thể có biến thành viên (instance variables) hay hàm khởi tạo (constructor). Một lớp có thể triển khai (implements) NHIỀU interface cùng lúc. Mục đích: Định nghĩa một “khả năng” mà các lớp không liên quan đến nhau có thể cùng sở hữu. Nó trả lời cho câu hỏi “Đối tượng này CÓ THỂ LÀM gì đó”. Ví dụ Code: Một interface Flyable định nghĩa khả năng bay. Cả Bird và Airplane đều có thể bay, nhưng chúng không có họ hàng gì với nhau.\n// Interface - Một bản hợp đồng về hành vi interface Flyable { void fly(); // Mặc định là public abstract } // Lớp Bird triển khai hợp đồng class Bird implements Flyable { @Override public void fly() { System.out.println(\"Bay bằng cách vỗ cánh\"); } } // Lớp Airplane cũng triển khai hợp đồng class Airplane implements Flyable { @Override public void fly() { System.out.println(\"Bay bằng động cơ phản lực\"); } } 3. So sánh trực tiếp: Abstract Class vs. Interface ⚖️ Để làm rõ sự khác biệt, chúng ta sẽ phân tích từng khía cạnh một cách chi tiết.\nVề Phương thức (Methods) Lớp trừu tượng (Abstract Class): Rất linh hoạt. Nó có thể chứa cả những phương thức đã được viết sẵn code (phương thức thông thường) để các lớp con dùng chung, và cả những phương thức trừu tượng (chưa có code) để buộc các lớp con phải tự định nghĩa. Giao diện (Interface): Tập trung vào việc định nghĩa “hợp đồng”. Nó chủ yếu chứa các phương thức trừu tượng, tức là chỉ nói ra cần làm gì chứ không nói làm như thế nào. (Lưu ý: từ Java 8 trở đi, Interface có thể có thêm default và static method, nhưng mục đích chính vẫn là định nghĩa hành vi). Về Biến và Trạng thái (Variables \u0026 State) Lớp trừu tượng (Abstract Class): Có thể chứa các biến thành viên (instance variables). Điều này có nghĩa là nó có thể lưu trữ “trạng thái” riêng cho từng đối tượng của lớp con. Giao diện (Interface): Không thể có biến thành viên. Nó chỉ có thể chứa các hằng số (biến public static final), là các giá trị không đổi và dùng chung cho tất cả. Về Hàm khởi tạo (Constructor) ⚙️ Lớp trừu tượng (Abstract Class): Có hàm khởi tạo. Mặc dù bạn không thể tạo đối tượng trực tiếp từ nó, constructor này sẽ được gọi bởi constructor của lớp con (thông qua từ khóa super()). Giao diện (Interface): Không có hàm khởi tạo. Về Cơ chế Kế thừa 🔗 Lớp trừu tượng (Abstract Class): Một lớp trong Java chỉ có thể kế thừa (extends) từ MỘT lớp trừu tượng duy nhất. Đây là quy tắc đơn kế thừa. Giao diện (Interface): Một lớp có thể triển khai (implements) NHIỀU giao diện cùng một lúc. Đây là cách Java cho phép “đa kế thừa” về mặt hành vi. Về Mục đích thiết kế (Design Purpose) Lớp trừu tượng (Abstract Class) - Mối quan hệ “IS-A” (Là một) 👨‍👩‍👧‍👦: Dùng khi các lớp con có chung một bản chất, thuộc cùng một “gia đình”. Ví dụ: một con Chó là một ĐộngVật. Giao diện (Interface) - Mối quan hệ “CAN-DO” (Có thể làm) 🏃‍♂️: Dùng khi bạn muốn định nghĩa một khả năng hoặc một hành vi. Các lớp có thể không liên quan gì đến nhau nhưng đều có thể thực hiện hành vi đó. Ví dụ: một con Chim và một cái MáyBay đều có thể bay (Flyable). ",
  "wordCount" : "1011",
  "inLanguage": "en",
  "datePublished": "2025-10-12T22:50:00+07:00",
  "dateModified": "2025-10-12T22:50:00+07:00",
  "author":{
    "@type": "Person",
    "name": "Hữu Khang"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://thanhprowin1.github.io/posts/abstract-class-vs-interface/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Blog của Hữu Khang",
    "logo": {
      "@type": "ImageObject",
      "url": "https://thanhprowin1.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://thanhprowin1.github.io/" accesskey="h" title="Blog của Hữu Khang (Alt + H)">Blog của Hữu Khang</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://thanhprowin1.github.io/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://thanhprowin1.github.io/posts/" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="https://thanhprowin1.github.io/about/" title="Về tôi">
                    <span>Về tôi</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      OOP: Abstract Class vs. Interface: Cuộc chiến của những &#39;Bản thiết kế&#39; trong Java
    </h1>
    <div class="post-description">
      Cả hai đều là những bản thiết kế cho các lớp khác, nhưng chúng phục vụ những mục đích rất khác nhau. Bài viết này sẽ làm rõ khi nào bạn nên dùng Lớp trừu tượng và khi nào nên dùng Giao diện.
    </div>
    <div class="post-meta"><span title='2025-10-12 22:50:00 +0700 +07'>October 12, 2025</span>&nbsp;·&nbsp;<span>Hữu Khang</span>

</div>
  </header> 
  <div class="post-content"><h2 id="giới-thiệu">Giới thiệu<a hidden class="anchor" aria-hidden="true" href="#giới-thiệu">#</a></h2>
<p>Trong Lập trình Hướng đối tượng, cả Lớp trừu tượng (Abstract Class) và Giao diện (Interface) đều là những &ldquo;bản thiết kế&rdquo; mà chúng ta không thể tạo ra đối tượng trực tiếp. Thay vào đó, chúng được dùng để các lớp khác kế thừa hoặc triển khai, nhằm tạo ra một bộ quy tắc và cấu trúc chung.</p>
<p>Tuy nhiên, việc lựa chọn giữa chúng giống như chọn giữa một bộ khung nhà có sẵn vài bức tường (Abstract Class) và một bản vẽ thiết kế chi tiết trên giấy (Interface). Hãy cùng tìm hiểu sự khác biệt cốt lõi nhé.</p>
<hr>
<h2 id="1-lớp-trừu-tượng-abstract-class---is-a-relationship">1. Lớp trừu tượng (Abstract Class) - &ldquo;IS-A&rdquo; Relationship<a hidden class="anchor" aria-hidden="true" href="#1-lớp-trừu-tượng-abstract-class---is-a-relationship">#</a></h2>
<p>Hãy nghĩ về một Abstract Class như một <strong>khuôn mẫu còn dang dở</strong>. Nó định nghĩa các đặc điểm và hành vi chung cho một nhóm các lớp có liên quan mật thiết với nhau.</p>
<ul>
<li><strong>Đặc điểm:</strong>
<ul>
<li>Có thể chứa cả <strong>phương thức trừu tượng</strong> (không có phần thân) và <strong>phương thức thông thường</strong> (có phần thân).</li>
<li>Có thể có các <strong>biến thành viên (instance variables)</strong>, <strong>hàm khởi tạo (constructor)</strong>.</li>
<li>Một lớp chỉ có thể <strong>kế thừa (extends) từ MỘT</strong> lớp trừu tượng duy nhất.</li>
</ul>
</li>
<li><strong>Mục đích:</strong> Chia sẻ code chung giữa các lớp con có cùng bản chất. Nó trả lời cho câu hỏi &ldquo;Đối tượng này <strong>LÀ MỘT</strong> cái gì đó&rdquo;.</li>
</ul>
<h3 id="ví-dụ-code">Ví dụ Code:<a hidden class="anchor" aria-hidden="true" href="#ví-dụ-code">#</a></h3>
<p>Một lớp <code>Animal</code> trừu tượng có thể có phương thức <code>sleep()</code> chung cho mọi con vật, nhưng phương thức <code>makeSound()</code> thì phải để cho từng lớp con (như <code>Dog</code>, <code>Cat</code>) tự định nghĩa.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// Lớp trừu tượng - Khuôn mẫu còn dang dở</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Animal</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> String name;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Constructor</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Animal</span>(String name) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> name;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Phương thức thông thường (có sẵn code)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sleep</span>() {
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(name <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; đang ngủ... zzz&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Phương thức trừu tượng (bắt buộc lớp con phải định nghĩa)</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">makeSound</span>();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Lớp con kế thừa</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> <span style="color:#66d9ef">extends</span> Animal {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Dog</span>(String name) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">super</span>(name);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">makeSound</span>() {
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Gâu gâu!&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h2 id="2-giao-diện-interface---can-do-relationship">2. Giao diện (Interface) - &ldquo;CAN-DO&rdquo; Relationship<a hidden class="anchor" aria-hidden="true" href="#2-giao-diện-interface---can-do-relationship">#</a></h2>
<p>Hãy nghĩ về một Interface như một <strong>bản hợp đồng</strong>. Nó chỉ định nghĩa những <strong>hành vi</strong> mà một lớp phải có, nhưng không quan tâm lớp đó thực hiện chúng như thế nào.</p>
<ul>
<li><strong>Đặc điểm:</strong>
<ul>
<li>Theo truyền thống, nó chỉ chứa các <strong>phương thức trừu tượng</strong> và các <strong>hằng số</strong> (<code>public static final</code>). (Java 8+ cho phép thêm <code>default</code> và <code>static</code> methods).</li>
<li><strong>Không thể</strong> có biến thành viên (instance variables) hay hàm khởi tạo (constructor).</li>
<li>Một lớp có thể <strong>triển khai (implements) NHIỀU</strong> interface cùng lúc.</li>
</ul>
</li>
<li><strong>Mục đích:</strong> Định nghĩa một &ldquo;khả năng&rdquo; mà các lớp không liên quan đến nhau có thể cùng sở hữu. Nó trả lời cho câu hỏi &ldquo;Đối tượng này <strong>CÓ THỂ LÀM</strong> gì đó&rdquo;.</li>
</ul>
<h3 id="ví-dụ-code-1">Ví dụ Code:<a hidden class="anchor" aria-hidden="true" href="#ví-dụ-code-1">#</a></h3>
<p>Một interface <code>Flyable</code> định nghĩa khả năng bay. Cả <code>Bird</code> và <code>Airplane</code> đều có thể bay, nhưng chúng không có họ hàng gì với nhau.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">// Interface - Một bản hợp đồng về hành vi</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Flyable</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fly</span>(); <span style="color:#75715e">// Mặc định là public abstract</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Lớp Bird triển khai hợp đồng</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Bird</span> <span style="color:#66d9ef">implements</span> Flyable {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fly</span>() {
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Bay bằng cách vỗ cánh&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Lớp Airplane cũng triển khai hợp đồng</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Airplane</span> <span style="color:#66d9ef">implements</span> Flyable {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fly</span>() {
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Bay bằng động cơ phản lực&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h2 id="3-so-sánh-trực-tiếp-abstract-class-vs-interface-">3. So sánh trực tiếp: Abstract Class vs. Interface ⚖️<a hidden class="anchor" aria-hidden="true" href="#3-so-sánh-trực-tiếp-abstract-class-vs-interface-">#</a></h2>
<p>Để làm rõ sự khác biệt, chúng ta sẽ phân tích từng khía cạnh một cách chi tiết.</p>
<h3 id="về-phương-thức-methods">Về Phương thức (Methods)<a hidden class="anchor" aria-hidden="true" href="#về-phương-thức-methods">#</a></h3>
<ul>
<li><strong>Lớp trừu tượng (Abstract Class):</strong> Rất linh hoạt. Nó có thể chứa cả những <strong>phương thức đã được viết sẵn code</strong> (phương thức thông thường) để các lớp con dùng chung, và cả những <strong>phương thức trừu tượng</strong> (chưa có code) để buộc các lớp con phải tự định nghĩa.</li>
<li><strong>Giao diện (Interface):</strong> Tập trung vào việc định nghĩa &ldquo;hợp đồng&rdquo;. Nó chủ yếu chứa các <strong>phương thức trừu tượng</strong>, tức là chỉ nói ra <em>cần làm gì</em> chứ không nói <em>làm như thế nào</em>. (Lưu ý: từ Java 8 trở đi, Interface có thể có thêm <code>default</code> và <code>static</code> method, nhưng mục đích chính vẫn là định nghĩa hành vi).</li>
</ul>
<h3 id="về-biến-và-trạng-thái-variables--state">Về Biến và Trạng thái (Variables &amp; State)<a hidden class="anchor" aria-hidden="true" href="#về-biến-và-trạng-thái-variables--state">#</a></h3>
<ul>
<li><strong>Lớp trừu tượng (Abstract Class):</strong> Có thể chứa các <strong>biến thành viên (instance variables)</strong>. Điều này có nghĩa là nó có thể lưu trữ &ldquo;trạng thái&rdquo; riêng cho từng đối tượng của lớp con.</li>
<li><strong>Giao diện (Interface):</strong> <strong>Không thể</strong> có biến thành viên. Nó chỉ có thể chứa các <strong>hằng số</strong> (biến <code>public static final</code>), là các giá trị không đổi và dùng chung cho tất cả.</li>
</ul>
<h3 id="về-hàm-khởi-tạo-constructor-">Về Hàm khởi tạo (Constructor) ⚙️<a hidden class="anchor" aria-hidden="true" href="#về-hàm-khởi-tạo-constructor-">#</a></h3>
<ul>
<li><strong>Lớp trừu tượng (Abstract Class):</strong> <strong>Có</strong> hàm khởi tạo. Mặc dù bạn không thể tạo đối tượng trực tiếp từ nó, constructor này sẽ được gọi bởi constructor của lớp con (thông qua từ khóa <code>super()</code>).</li>
<li><strong>Giao diện (Interface):</strong> <strong>Không có</strong> hàm khởi tạo.</li>
</ul>
<h3 id="về-cơ-chế-kế-thừa-">Về Cơ chế Kế thừa 🔗<a hidden class="anchor" aria-hidden="true" href="#về-cơ-chế-kế-thừa-">#</a></h3>
<ul>
<li><strong>Lớp trừu tượng (Abstract Class):</strong> Một lớp trong Java chỉ có thể <strong>kế thừa (<code>extends</code>) từ MỘT</strong> lớp trừu tượng duy nhất. Đây là quy tắc đơn kế thừa.</li>
<li><strong>Giao diện (Interface):</strong> Một lớp có thể <strong>triển khai (<code>implements</code>) NHIỀU</strong> giao diện cùng một lúc. Đây là cách Java cho phép &ldquo;đa kế thừa&rdquo; về mặt hành vi.</li>
</ul>
<h3 id="về-mục-đích-thiết-kế-design-purpose">Về Mục đích thiết kế (Design Purpose)<a hidden class="anchor" aria-hidden="true" href="#về-mục-đích-thiết-kế-design-purpose">#</a></h3>
<ul>
<li><strong>Lớp trừu tượng (Abstract Class) - Mối quan hệ &ldquo;IS-A&rdquo; (Là một) 👨‍👩‍👧‍👦:</strong> Dùng khi các lớp con có chung một <strong>bản chất</strong>, thuộc cùng một &ldquo;gia đình&rdquo;. Ví dụ: một con <code>Chó</code> <strong>là một</strong> <code>ĐộngVật</code>.</li>
<li><strong>Giao diện (Interface) - Mối quan hệ &ldquo;CAN-DO&rdquo; (Có thể làm) 🏃‍♂️:</strong> Dùng khi bạn muốn định nghĩa một <strong>khả năng</strong> hoặc một <strong>hành vi</strong>. Các lớp có thể không liên quan gì đến nhau nhưng đều có thể thực hiện hành vi đó. Ví dụ: một con <code>Chim</code> và một cái <code>MáyBay</code> đều <strong>có thể bay</strong> (<code>Flyable</code>).</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://thanhprowin1.github.io/">Blog của Hữu Khang</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
